import { NextResponse } from 'next/server'\nimport Stripe from 'stripe'\nimport { firestore } from '@/lib/firebase/admin'\nimport admin from 'firebase-admin'\n\n// Stripe requires the raw request body for signature verification\nexport const config = {\n  api: { bodyParser: false },\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: '2024-06-20',\n})\n\n// Server-side helper to find a user document by email\nconst findUserByEmail = async (email: string) => {\n  const usersRef = firestore.collection('users');\n  const snapshot = await usersRef.where('email', '==', email).limit(1).get();\n  if (snapshot.empty) {\n    console.warn(`No user found with email: ${email}`);\n    return null;\n  }\n  const userDoc = snapshot.docs[0];\n  return { id: userDoc.id, ref: userDoc.ref, ...userDoc.data() };\n}\n\nexport async function POST(req: Request) {\n  const sig = req.headers.get('stripe-signature')!\n  let event: Stripe.Event\n\n  try {\n    const buf = await req.arrayBuffer()\n    event = stripe.webhooks.constructEvent(\n      Buffer.from(buf),\n      sig,\n      process.env.STRIPE_WEBHOOK_SECRET!\n    )\n  } catch (err: any) {\n    console.error('‚ùå Stripe signature verification failed', err.message)\n    return new NextResponse(`Webhook Error: ${err.message}`, { status: 400 })\n  }\n\n  try {\n    const timestamp = admin.firestore.FieldValue.serverTimestamp();\n\n    switch (event.type) {\n      case 'checkout.session.completed': {\n        const session = event.data.object as Stripe.Checkout.Session\n        const email = session.customer_details?.email || session.customer_email;\n        const metadataType = session.metadata?.type;\n\n        if (!email) {\n            console.error('No email found in checkout session.');\n            break;\n        }\n\n        const user = await findUserByEmail(email);\n        if (!user) break; // Error already logged in helper\n\n        if (metadataType === 'verification' || metadataType === 'report') {\n          const collectionName = metadataType === 'verification' ? 'verifications' : 'reports';\n          \n          await firestore.collection(collectionName).add({\n            createdBy: user.id,\n            aiConfidence: metadataType === 'verification' ? Math.floor(Math.random() * 10) + 90 : undefined,\n            riskScore: metadataType === 'report' ? Math.floor(Math.random() * 40) + 60 : undefined,\n            riskLevel: metadataType === 'report' ? 'Moderate' : undefined,\n            verificationType: 'summary',\n            createdAt: timestamp,\n          });\n\n          await user.ref.update({ creditsRemaining: admin.firestore.FieldValue.increment(-1) });\n          console.log(`‚úÖ ${metadataType} processed for ${email}. Credits decremented.`);\n        }\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object as Stripe.Invoice;\n        const email = invoice.customer_email;\n        if (!email) break;\n\n        const user = await findUserByEmail(email);\n        if (!user) break;\n\n        const planId = invoice.lines.data[0]?.price?.lookup_key;\n        let credits = 10; // Default plan\n        if (planId === 'price_pro_plan') credits = 50;\n        if (planId === 'price_unlimited_plan') credits = 9999;\n\n        await user.ref.update({\n          plan: planId,\n          creditsRemaining: credits,\n          nextBillingDate: admin.firestore.Timestamp.fromMillis(invoice.period_end * 1000),\n        });\n        console.log(`‚úÖ Subscription renewal for ${email}. Plan: ${planId}, Credits: ${credits}`);\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object as Stripe.Subscription;\n        const user = await findUserByEmail(subscription.metadata.email);\n        if (!user) break;\n\n        await user.ref.update({\n          plan: 'free',\n          creditsRemaining: 0,\n        });\n        console.log(`‚úÖ Subscription canceled for ${subscription.metadata.email}. Plan set to free.`);\n        break;\n      }\n\n      default:{\n        // console.log(`Unhandled Stripe event type: ${event.type}`)\n      }\n        \n    }\n\n    return NextResponse.json({ received: true })\n  } catch (err: any) {\n    console.error('üî• Stripe webhook handler error:', err)\n    return new NextResponse(`Webhook handler failed: ${err.message}`, { status: 500 })\n  }\n}\n